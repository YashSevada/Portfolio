"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FaxesApi = void 0;
const sdk_client_1 = require("@sinch/sdk-client");
const fax_domain_api_1 = require("../fax-domain-api");
const FormData = require("form-data");
const fs = __importStar(require("fs"));
class FaxesApi extends fax_domain_api_1.FaxDomainApi {
    /**
     * Initialize your interface
     *
     * @param {SinchClientParameters} sinchClientParameters - The parameters used to initialize the API Client.
     */
    constructor(sinchClientParameters) {
        super(sinchClientParameters, 'FaxesApi');
    }
    /**
     * Delete fax content
     * Delete the fax content for a fax using the ID number of the fax. Please note that this only deletes the content of the fax from storage.
     * @param { DeleteFaxContentRequestData } data - The data to provide to the API call.
     */
    async deleteContent(data) {
        this.client = this.getSinchClient();
        const getParams = this.client.extractQueryParams(data, []);
        const headers = {
            'Content-Type': 'application/json',
            'Accept': 'application/json',
        };
        const body = '';
        const basePathUrl = `${this.client.apiClientOptions.hostname}/v3/projects/${this.client.apiClientOptions.projectId}/faxes/${data['id']}/file`;
        const requestOptions = await this.client.prepareOptions(basePathUrl, 'DELETE', getParams, headers, body || undefined);
        const url = this.client.prepareUrl(requestOptions.hostname, requestOptions.queryParams);
        return this.client.processCall({
            url,
            requestOptions,
            apiName: this.apiName,
            operationId: 'DeleteFaxContentById',
        });
    }
    /**
     * Download fax content
     * Download the fax content.
     * @param { DownloadFaxContentRequestData } data - The data to provide to the API call.
     */
    async downloadContent(data) {
        this.client = this.getSinchClient();
        data['fileFormat'] = data['fileFormat'] !== undefined ? data['fileFormat'] : 'pdf';
        const getParams = this.client.extractQueryParams(data, []);
        const headers = {
            'Content-Type': 'application/json',
            'Accept': 'application/pdf',
        };
        const body = '';
        const basePathUrl = `${this.client.apiClientOptions.hostname}/v3/projects/${this.client.apiClientOptions.projectId}/faxes/${data['id']}/file.${data['fileFormat']}`;
        const requestOptions = await this.client.prepareOptions(basePathUrl, 'GET', getParams, headers, body || undefined);
        const url = this.client.prepareUrl(requestOptions.hostname, requestOptions.queryParams);
        return this.client.processFileCall({
            url,
            requestOptions,
            apiName: this.apiName,
            operationId: 'GetFaxFileById',
        });
    }
    /**
     * Get fax
     * Get fax information using the ID number of the fax.
     * @param { GetFaxRequestData } data - The data to provide to the API call.
     */
    async get(data) {
        this.client = this.getSinchClient();
        const getParams = this.client.extractQueryParams(data, []);
        const headers = {
            'Content-Type': 'application/json',
            'Accept': 'application/json',
        };
        const body = '';
        const basePathUrl = `${this.client.apiClientOptions.hostname}/v3/projects/${this.client.apiClientOptions.projectId}/faxes/${data['id']}`;
        const requestOptions = await this.client.prepareOptions(basePathUrl, 'GET', getParams, headers, body || undefined);
        const url = this.client.prepareUrl(requestOptions.hostname, requestOptions.queryParams);
        return this.client.processCall({
            url,
            requestOptions,
            apiName: this.apiName,
            operationId: 'GetFaxInfoPerId',
        });
    }
    /**
     * List faxes
     * List faxes sent (OUTBOUND) or received (INBOUND), set parameters to filter the list. Example: Return calls made between 1st of January 2021 and  10th of January 2021. &#x60;&#x60;&#x60;  created&gt;&#x3D;2021-01-01&amp;startTime&lt;&#x3D;2021-01-10 &#x60;&#x60;&#x60;
     * @param { ListFaxesRequestData } data - The data to provide to the API call.
     * @return {ApiListPromise<Fax>}
     */
    list(data) {
        this.client = this.getSinchClient();
        const getParams = this.client.extractQueryParams(data, [
            'direction',
            'status',
            'to',
            'from',
            'pageSize',
            'page'
        ]);
        getParams.createTime = JSON.stringify((0, sdk_client_1.formatCreateTimeFilter)(data.createTime));
        getParams['createTime>'] = JSON.stringify((0, sdk_client_1.formatCreateTimeRangeFilter)(data.createTimeRange?.from));
        getParams['createTime<'] = JSON.stringify((0, sdk_client_1.formatCreateTimeRangeFilter)(data.createTimeRange?.to));
        const headers = {
            'Content-Type': 'application/json',
            'Accept': 'application/json',
        };
        const body = '';
        const basePathUrl = `${this.client.apiClientOptions.hostname}/v3/projects/${this.client.apiClientOptions.projectId}/faxes`;
        const requestOptionsPromise = this.client.prepareOptions(basePathUrl, 'GET', getParams, headers, body || undefined);
        const operationProperties = {
            pagination: sdk_client_1.PaginationEnum.PAGE3,
            apiName: this.apiName,
            operationId: 'GetFaxes',
            dataKey: 'faxes',
        };
        // Create the promise containing the response wrapped as a PageResult
        const listPromise = (0, sdk_client_1.buildPageResultPromise)(this.client, requestOptionsPromise, operationProperties);
        // Add properties to the Promise to offer the possibility to use it as an iterator
        Object.assign(listPromise, (0, sdk_client_1.createIteratorMethodsForPagination)(this.client, requestOptionsPromise, listPromise, operationProperties));
        return listPromise;
    }
    /**
     * Send a fax or multiple faxes
     * Create and send one or multiple faxes. Fax content may be supplied via one or more files or URLs of supported filetypes.
     * This endpoint supports the following content types for the fax payload:
     *   - Multipart/form-data
     *   - Application/json
     * We will however always return a fax array in the response in application json.
     * If you supply a callbackUrl the callback will be sent as multipart/form-data with the content of the fax as an attachment to the body, *unless* you specify callbackUrlContentType as application/json.
     * #### file(s)
     *    Files may be included in the POST request as multipart/form-data parts.
     * #### contentUrl
     *    Any URL on the Internet (including ones with basic authentication), and we'll pull it down and make it a fax. This might be useful to you if you're using a web framework for templates and creating fax files.
     *    Please note: If you are passing fax a secure URL (starting with 'https://'), make sure that your SSL certificate (including your intermediate cert, if you have one) is installed properly, valid, and up-to-date.
     * @param { SendFaxRequestData } data - The data to provide to the API call.
     */
    async send(data) {
        this.client = this.getSinchClient();
        const requestBody = data.sendFaxRequestBody;
        requestBody['headerText'] = requestBody['headerText'] !== undefined
            ? requestBody['headerText'] : '';
        requestBody['headerPageNumbers'] = requestBody['headerPageNumbers'] !== undefined
            ? requestBody['headerPageNumbers'] : true;
        requestBody['headerTimeZone'] = requestBody['headerTimeZone'] !== undefined
            ? requestBody['headerTimeZone'] : 'America/New_York';
        requestBody['retryDelaySeconds'] = requestBody['retryDelaySeconds'] !== undefined
            ? requestBody['retryDelaySeconds'] : 60;
        requestBody['callbackUrlContentType'] = requestBody['callbackUrlContentType'] !== undefined
            ? requestBody['callbackUrlContentType'] : 'multipart/form-data';
        requestBody['imageConversionMethod'] = requestBody['imageConversionMethod'] !== undefined
            ? requestBody['imageConversionMethod'] : 'HALFTONE';
        const getParams = this.client.extractQueryParams(data, []);
        const headers = {
            'Accept': 'application/json',
        };
        let body;
        // Except if the request body contains a non-empty property 'files' (where the message will be sent as application/json)
        // the request will be sent as multipart/formdata
        const isUsingJson = data['sendFaxRequestBody'].files !== undefined;
        if (isUsingJson) {
            headers['Content-Type'] = 'application/json';
            body = JSON.stringify(data['sendFaxRequestBody']);
        }
        else {
            const formData = new FormData();
            let requestData;
            if (Array.isArray(data.sendFaxRequestBody.to)) {
                requestData = data.sendFaxRequestBody;
                requestData.to.forEach((to) => formData.append('to', to));
            }
            else {
                requestData = data.sendFaxRequestBody;
                formData.append('to', requestData.to);
            }
            if (requestData.filePaths) {
                let attachmentPaths = requestData.filePaths;
                if (typeof attachmentPaths === 'string') {
                    attachmentPaths = [String(requestData.filePaths)];
                }
                attachmentPaths.forEach((filePath) => {
                    formData.append('file', fs.readFileSync(filePath), filePath.split('/').pop());
                });
            }
            if (requestData.from) {
                formData.append('from', requestData.from);
            }
            if (requestData.contentUrl) {
                formData.append('contentUrl', requestData.contentUrl);
            }
            if (requestData.headerText) {
                formData.append('headerText', requestData.headerText);
            }
            if (requestData.headerPageNumbers) {
                formData.append('headerPageNumbers', requestData.headerPageNumbers.toString());
            }
            if (requestData.headerTimeZone) {
                formData.append('headerTimeZone', requestData.headerTimeZone);
            }
            if (requestData.retryDelaySeconds) {
                formData.append('retryDelaySeconds', requestData.retryDelaySeconds);
            }
            if (requestData.labels) {
                formData.append('labels', requestData.labels);
            }
            if (requestData.callbackUrl) {
                formData.append('callbackUrl', requestData.callbackUrl);
            }
            if (requestData.callbackUrlContentType) {
                formData.append('callbackUrlContentType', requestData.callbackUrlContentType);
            }
            if (requestData.imageConversionMethod) {
                formData.append('imageConversionMethod', requestData.imageConversionMethod);
            }
            if (requestData.serviceId) {
                formData.append('serviceId', requestData.serviceId);
            }
            if (requestData.maxRetries) {
                formData.append('maxRetries', requestData.maxRetries);
            }
            body = formData;
        }
        const basePathUrl = `${this.client.apiClientOptions.hostname}/v3/projects/${this.client.apiClientOptions.projectId}/faxes`;
        const requestOptions = await this.client.prepareOptions(basePathUrl, 'POST', getParams, headers, body || undefined);
        const url = this.client.prepareUrl(requestOptions.hostname, requestOptions.queryParams);
        if (Array.isArray(data.sendFaxRequestBody.to)) {
            const responseData = await this.client.processCall({
                url,
                requestOptions,
                apiName: this.apiName,
                operationId: 'SendMultipleFax',
            });
            // When there is a single element in the 'to' array, the server will return a Fax, not a FaxList
            if (Array.isArray(responseData.faxes)) {
                return responseData.faxes;
            }
            else {
                return [responseData];
            }
        }
        else {
            const responseData = await this.client.processCall({
                url,
                requestOptions,
                apiName: this.apiName,
                operationId: 'SendFax',
            });
            return [responseData];
        }
    }
}
exports.FaxesApi = FaxesApi;
//# sourceMappingURL=faxes-api.js.map